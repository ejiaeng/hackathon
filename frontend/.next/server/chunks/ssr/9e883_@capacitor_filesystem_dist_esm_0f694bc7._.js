module.exports=[9019,a=>{"use strict";var b,c,d,e;(d=b||(b={})).Documents="DOCUMENTS",d.Data="DATA",d.Library="LIBRARY",d.Cache="CACHE",d.External="EXTERNAL",d.ExternalStorage="EXTERNAL_STORAGE",d.ExternalCache="EXTERNAL_CACHE",d.LibraryNoCloud="LIBRARY_NO_CLOUD",d.Temporary="TEMPORARY",(e=c||(c={})).UTF8="utf8",e.ASCII="ascii",e.UTF16="utf16",a.s(["Encoding",()=>c])},42739,a=>{"use strict";var b=a.i(74808),c=a.i(9019);function d(a){let b=a.split("/").filter(a=>"."!==a),c=[];return b.forEach(a=>{".."===a&&c.length>0&&".."!==c[c.length-1]?c.pop():c.push(a)}),c.join("/")}class e extends b.WebPlugin{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=async a=>{var c,d;let e,f=(0,b.buildRequestInit)(a,a.webFetchExtra),g=await fetch(a.url,f);if(a.progress)if(null==g?void 0:g.body){let b=g.body.getReader(),c=0,d=[],f=g.headers.get("content-type"),h=parseInt(g.headers.get("content-length")||"0",10);for(;;){let{done:e,value:f}=await b.read();if(e)break;d.push(f),c+=(null==f?void 0:f.length)||0;let g={url:a.url,bytes:c,contentLength:h};this.notifyListeners("progress",g)}let i=new Uint8Array(c),j=0;for(let a of d)void 0!==a&&(i.set(a,j),j+=a.length);e=new Blob([i.buffer],{type:f||void 0})}else e=new Blob;else e=await g.blob();return{path:(await this.writeFile({path:a.path,directory:null!=(c=a.directory)?c:void 0,recursive:null!=(d=a.recursive)&&d,data:e})).uri,blob:e}}}readFileInChunks(a,b){throw this.unavailable("Method not implemented.")}async initDb(){if(void 0!==this._db)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((a,b)=>{let c=indexedDB.open(this.DB_NAME,this.DB_VERSION);c.onupgradeneeded=e.doUpgrade,c.onsuccess=()=>{this._db=c.result,a(c.result)},c.onerror=()=>b(c.error),c.onblocked=()=>{console.warn("db blocked")}})}static doUpgrade(a){let b=a.target.result;a.oldVersion,b.objectStoreNames.contains("FileStorage")&&b.deleteObjectStore("FileStorage"),b.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}async dbRequest(a,b){let c=-1!==this._writeCmds.indexOf(a)?"readwrite":"readonly";return this.initDb().then(d=>new Promise((e,f)=>{let g=d.transaction(["FileStorage"],c).objectStore("FileStorage")[a](...b);g.onsuccess=()=>e(g.result),g.onerror=()=>f(g.error)}))}async dbIndexRequest(a,b,c){let d=-1!==this._writeCmds.indexOf(b)?"readwrite":"readonly";return this.initDb().then(e=>new Promise((f,g)=>{let h=e.transaction(["FileStorage"],d).objectStore("FileStorage").index(a)[b](...c);h.onsuccess=()=>f(h.result),h.onerror=()=>g(h.error)}))}getPath(a,b){let c=void 0!==b?b.replace(/^[/]+|[/]+$/g,""):"",d="";return void 0!==a&&(d+="/"+a),""!==b&&(d+="/"+c),d}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(a){let b=this.getPath(a.directory,a.path),c=await this.dbRequest("get",[b]);if(void 0===c)throw Error("File does not exist.");return{data:c.content?c.content:""}}async writeFile(a){let b=this.getPath(a.directory,a.path),c=a.data,d=a.encoding,e=a.recursive,f=await this.dbRequest("get",[b]);if(f&&"directory"===f.type)throw Error("The supplied path is a directory.");let g=b.substr(0,b.lastIndexOf("/"));if(void 0===await this.dbRequest("get",[g])){let b=g.indexOf("/",1);if(-1!==b){let c=g.substr(b);await this.mkdir({path:c,directory:a.directory,recursive:e})}}if(!d&&!(c instanceof Blob)&&(c=c.indexOf(",")>=0?c.split(",")[1]:c,!this.isBase64String(c)))throw Error("The supplied data is not valid base64 content.");let h=Date.now(),i={path:b,folder:g,type:"file",size:c instanceof Blob?c.size:c.length,ctime:h,mtime:h,content:c};return await this.dbRequest("put",[i]),{uri:i.path}}async appendFile(a){let b=this.getPath(a.directory,a.path),c=a.data,d=a.encoding,e=b.substr(0,b.lastIndexOf("/")),f=Date.now(),g=f,h=await this.dbRequest("get",[b]);if(h&&"directory"===h.type)throw Error("The supplied path is a directory.");if(void 0===await this.dbRequest("get",[e])){let b=e.indexOf("/",1);if(-1!==b){let c=e.substr(b);await this.mkdir({path:c,directory:a.directory,recursive:!0})}}if(!d&&!this.isBase64String(c))throw Error("The supplied data is not valid base64 content.");if(void 0!==h){if(h.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");c=void 0===h.content||d?h.content+c:btoa(atob(h.content)+atob(c)),g=h.ctime}let i={path:b,folder:e,type:"file",size:c.length,ctime:g,mtime:f,content:c};await this.dbRequest("put",[i])}async deleteFile(a){let b=this.getPath(a.directory,a.path);if(void 0===await this.dbRequest("get",[b]))throw Error("File does not exist.");if(0!==(await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(b)])).length)throw Error("Folder is not empty.");await this.dbRequest("delete",[b])}async mkdir(a){let b=this.getPath(a.directory,a.path),c=a.recursive,d=b.substr(0,b.lastIndexOf("/")),e=(b.match(/\//g)||[]).length,f=await this.dbRequest("get",[d]),g=await this.dbRequest("get",[b]);if(1===e)throw Error("Cannot create Root directory");if(void 0!==g)throw Error("Current directory does already exist.");if(!c&&2!==e&&void 0===f)throw Error("Parent directory must exist");if(c&&2!==e&&void 0===f){let b=d.substr(d.indexOf("/",1));await this.mkdir({path:b,directory:a.directory,recursive:c})}let h=Date.now();await this.dbRequest("put",[{path:b,folder:d,type:"directory",size:0,ctime:h,mtime:h}])}async rmdir(a){let{path:b,directory:c,recursive:d}=a,e=this.getPath(c,b),f=await this.dbRequest("get",[e]);if(void 0===f)throw Error("Folder does not exist.");if("directory"!==f.type)throw Error("Requested path is not a directory");let g=await this.readdir({path:b,directory:c});if(0!==g.files.length&&!d)throw Error("Folder is not empty");for(let a of g.files){let e=`${b}/${a.name}`;"file"===(await this.stat({path:e,directory:c})).type?await this.deleteFile({path:e,directory:c}):await this.rmdir({path:e,directory:c,recursive:d})}await this.dbRequest("delete",[e])}async readdir(a){let b=this.getPath(a.directory,a.path),c=await this.dbRequest("get",[b]);if(""!==a.path&&void 0===c)throw Error("Folder does not exist.");let d=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(b)]);return{files:await Promise.all(d.map(async a=>{let c=await this.dbRequest("get",[a]);return void 0===c&&(c=await this.dbRequest("get",[a+"/"])),{name:a.substring(b.length+1),type:c.type,size:c.size,ctime:c.ctime,mtime:c.mtime,uri:c.path}}))}}async getUri(a){let b=this.getPath(a.directory,a.path),c=await this.dbRequest("get",[b]);return void 0===c&&(c=await this.dbRequest("get",[b+"/"])),{uri:(null==c?void 0:c.path)||b}}async stat(a){let b=this.getPath(a.directory,a.path),c=await this.dbRequest("get",[b]);if(void 0===c&&(c=await this.dbRequest("get",[b+"/"])),void 0===c)throw Error("Entry does not exist.");return{name:c.path.substring(b.length+1),type:c.type,size:c.size,ctime:c.ctime,mtime:c.mtime,uri:c.path}}async rename(a){await this._copy(a,!0)}async copy(a){return this._copy(a,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(a,b=!1){var e,f;let g,h,i,{toDirectory:j}=a,{to:k,from:l,directory:m}=a;if(!k||!l)throw Error("Both to and from must be provided");j||(j=m);let n=this.getPath(m,l),o=this.getPath(j,k);if(n===o)return{uri:o};if(e=n,f=o,e=d(e),f=d(f),g=e.split("/"),h=f.split("/"),e!==f&&g.every((a,b)=>a===h[b]))throw Error("To path cannot contain the from path");try{i=await this.stat({path:k,directory:j})}catch(c){let a=k.split("/");a.pop();let b=a.join("/");if(a.length>0&&"directory"!==(await this.stat({path:b,directory:j})).type)throw Error("Parent directory of the to path is a file")}if(i&&"directory"===i.type)throw Error("Cannot overwrite a directory with a file");let p=await this.stat({path:l,directory:m}),q=async(a,b,c)=>{let d=this.getPath(j,a),e=await this.dbRequest("get",[d]);e.ctime=b,e.mtime=c,await this.dbRequest("put",[e])},r=p.ctime?p.ctime:Date.now();switch(p.type){case"file":{let a,d=await this.readFile({path:l,directory:m});b&&await this.deleteFile({path:l,directory:m}),d.data instanceof Blob||this.isBase64String(d.data)||(a=c.Encoding.UTF8);let e=await this.writeFile({path:k,directory:j,data:d.data,encoding:a});return b&&await q(k,r,p.mtime),e}case"directory":if(i)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:k,directory:j,recursive:!1}),b&&await q(k,r,p.mtime)}catch(a){}for(let a of(await this.readdir({path:l,directory:m})).files)await this._copy({from:`${l}/${a.name}`,to:`${k}/${a.name}`,directory:m,toDirectory:j},b);b&&await this.rmdir({path:l,directory:m})}return{uri:o}}isBase64String(a){try{return btoa(atob(a))==a}catch(a){return!1}}}e._debug=!0,a.s(["FilesystemWeb",()=>e])}];

//# sourceMappingURL=9e883_%40capacitor_filesystem_dist_esm_0f694bc7._.js.map